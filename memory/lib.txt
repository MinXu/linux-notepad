		Linux下静态、动态库（隐式、显式调用）的创建和使用及区别 
==========================================================================================
http://blog.csdn.net/star_xiong/article/details/17301191
==========================================================================================
一、静态链接库的创建与使用：
2、现在首先要明确我们目的是将add.c做成静态链接库，然后main.c调用生成的静态链接库中的add()
(1)将add.c做成静态链接库(创建静态库):
首先将add.c编译成目标文件(add.o文件),如下：
   #gcc -c add.c             //生成add.o
然后将生成的目标文件(add.o)生成静态库libadd.a：
   #ar crv libadd.a add.o    //生成libadd.a
(2)静态库做好了，就可以在编译main.c时将静态库链接进去了，接下来就编译生成可执行文件(静态库的使用)：
   #gcc -o exe main.c -I. -L. -ladd  
   //或者 #gcc -o exe main.c ./libadd.a
   //或者 #gcc -o exe main.c -L. libadd.a
(注：这里的-I/路径, -L/路径, 是通过-I和-L指定对应的库文件名和库文件的路径,这里就是当前目录，
  libadd.a就是要用的静态库，这样对应的静态库已经编译到对应的可执行程序中。执行对应的可执行文件
  便可以得到对应函数调用的结果。在main.c中不需要包含导出文件的头文件。
  上面的(2)分开就是：
  1)编译生成对应的目标文件： 
     #gcc -c -I/home/hcj/xxxxxxxx main.c  
  2)生成可执行文件： 
     #gcc -o exe -L/home/hcj/xxxxxxxx main.o libstr.a  
  还有若主函数是C++程序（即.cpp），则需要在main.cpp中用extern "C"{}包含被调用函数(add.c)的头文件，
  编译时用g++编译或者还用gcc编译但需加上一个链接c++库的参数(-lstdc++)
)


二、动态链接库的创建与使用：
==========================================================================================
				补充介绍
动态库是程序设计常用的技术，采用动态库可以有效的减少程序大小，节省空间，提高效率，增加程序的可扩展性，
便于模块化管理。在Windows和Linux操作系统中都有动态库的概念。Windows将其称为动态链接库（Dynamic Link Library，DLL），
其文件扩展名为.dll，Linux称其为共享库技术（Shared Library），相应的共享库文件扩展名为.so。

故名思义，动态库在程序运行的时候被动态链接。但是在具体使用动态库的时候却有两种不同的方式：隐式链接和显式链接。
隐式链接在编译/链接阶段完成，由编译系统根据动态库的头文件和库文件进行编译和链接，从而确定待调用的函数原形和地址。
显式链接则是利用API函数实现加载和卸载共享库，获取带调用函数地址，获取错误信息等功能。
==========================================================================================
1、把add.c编译生成动态库(创建动态库)：
   #gcc -fPIC -c add.c    //生成add.o
   #gcc -shared -o libadd.so add.o     /* 或者 #ar crv libadd.so add.o */
(上面两行可以整合成一行：#gcc -fPIC -shared -o libadd.so add.c)
注：-fpic 使输出的对象模块是按照可重定位地址方式生成的(即与位置无关)。 
    -shared指定把对应的源文件生成对应的动态链接库文件libstr.so文件


2、动态库的使用(动态链接库分：隐式调用和显式调用2种)：
(1)隐式调用：
动态链接库（隐式调用）在代码上与写静态链接库没什么区别，主要是在编译时。
代码编写与静态库一样，不需要包含导出函数的头文件，若主函数是C++程序（即.cpp），则需要在main.cpp中用
extern "C"{}包含被调用函数(add.c)的头文件(这里需要包含头文件是与.cpp和.c混合编译有关，同静态\动态库
无关)，编译时用g++编译或者还用gcc编译但需加上一个链接c++库的参数(-lstdc++)
1)代码编写： 与静态库一样
2)编译main.c生成可执行程序(动态库隐式调用的使用):
   #gcc -o exe main.c ./libadd.so
  (或者 #gcc -o exe main.c -L. libadd.so
   再或者将libadd.so copy到目录 /usr/lib或/lib中，然后执行：
   #gcc -o exe main.c libadd.so //此时不需要指定搜索路径
  )
   注： 最直接最简单的方法就是把libadd.so拉到/usr/lib或/lib中去。 、
        还有一种方法 export LD_LIBRARY_PATH=$(pwd) 
        另外还可以在/etc/ld.so.conf文件里加入我们生成的库的目录，然后执行#/sbin/ldconfig。
           /etc/ld.so.conf是非常重要的一个目录，里面存放的是链接器和加载器搜索共享库时要检查的目录，
           默认是从/usr/lib /lib中读取的，所以想要顺利运行，我们也可以把我们库的目录加入到这个文件中
           并执行/sbin/ldconfig 。另外还有个文件需要了解/etc/ld.so.cache,里面保存了常用的动态函数
           库，且会先把他们加载到内存中，因为内存的访问速度远远大于硬盘的访问速度，这样可以提高软件加载
           动态函数库的速度了。 
3)#./exe
(2)显式调用：
   显式调用的动态库的创建与隐式调用相同。（隐式调用与静态库的使用方法一样，不需要包含导出函数的头文件(显式调用
   也不用包含头文件)，只需要在编译可执行程序时指定库文件的路径）
   显式调用和隐式调用的区别在于：编译可执行程序时需要指定库文件的搜索路径，而显式调用编译可执行程序时不用加上
   动态库的搜索路径(因为已经在主函数中包含了库文件的路径)，但是需要增加几个系统调用:
   (#include <dlfcn.h>,   //头文件 
1）dlopen()
   第一个参数：指定共享库的名称，将会在下面位置查找指定的共享库。 
      －环境变量LD_LIBRARY_PATH列出的用分号间隔的所有目录。 
      －文件/etc/ld.so.cache中找到的库的列表，用ldconfig维护。 
      －目录usr/lib。 
      －目录/lib。 
      －当前目录。 
   第二个参数：指定如何打开共享库。 
      －RTLD_NOW：将共享库中的所有函数加载到内存 
      －RTLD_LAZY：会推后共享库中的函数的加载操作，直到调用dlsym()时方加载某函数 
   返回值：返回动态库的句柄
2）dlsym()
   调用dlsym时，利用dlopen()返回的共享库的句柄以及函数名称作为参数，返回要加载函数的入口地址。
3）dlclose()
   关闭动态链接库
4）dlerror() 
   该函数用于检查调用共享库的相关函数出现的错误。 
   如果dlerror返回值不为空,则dlsym执行出错
)

Example:
1、编写add.c 及main.c代码：
/**************************************************************************/
/*add.c*/
int add(int x, int y)
{
   return x + y;
   return 0;
}
/*************************************************************************/
然后add.h代码为：
/*add.h*/
#ifndef _ADD_H_
#define _ADD_H_

int add(int, int);

#endif
/***************************************************************************/
main函数代码：
/*main.c*/
#include <stdio.h>
#include <dlfcn.h>   //显式加载需要用到的头文件

#define LIB  "./libadd.so"   //指定动态库路径

int main(void)
{
   void *dl;
   char *error;
   int (*func)();

   dl = dlopen(LIB, RTLD_LAZY); /*打开动态链接库*/
   if(dl == NULL)
   {
      printf("Failed load libary\n");
   }

   error = dlerror(); /*检测错误*/
   if(error != NULL)
   {
      printf("%s\n", error);
      return -1;
   }

   func = dlsym(dl, "test"); /*获取函数的地址*/
   error = dlerror(); /*检测错误*/
   if(error != NULL)
   {
      printf("%s\n", error);
      return -1;
   }

   func(); /*调用动态库中函数*/

   dlclose(dl);  /*关闭共享库*/
   error = dlerror(); /*检测错误*/
   if(error != NULL)
   {
      printf("%s\n", error);
      return -1;
   }

   return 0;
}
/**********************************************************************************/
2、编译main.c生成可执行程序,动态库的创建已经在上面讲了(动态库显式调用):
1)#gcc -ldl -o exe mian.c
注意要添加-ldl选项，以使用显式调用相关的函数调用。
可以看到，显式调用的代码看上去要复杂很多，但是却比隐式调用要灵活，我们不必在编译时就确定要加载哪个动态链接库，可以在运行时再确定，甚至重新加载。
2)#./exe



==========================================================================================
==			动态库生成参数 rdynamic                                          ==
==========================================================================================
动态库生成参数 rdynamic 
gcc -o libdl_func.so -fPIC -rdynamic -shared dl_func.c
选项 -rdynamic 用来通知链接器将所有符号添加到动态符号表中
（目的是能够通过使用 dlopen 来实现向后跟踪）
-rdynamic
Pass the flag ‘-export-dynamic’ to the ELF linker, on targets that support
it. This instructs the linker to add all symbols, not only used ones, to the
dynamic symbol table. This option is needed for some uses of dlopen or to
allow obtaining backtraces from within a program.

比如日志系统，主程序里使用一套日志系统，dlopen方式打开的libso里无法使用。编译时加上这个参数，不需要增加任何代码就可以使代码通用。
==========================================================================================


==========================================================================================
==			     ldconfig                                                   ==
==========================================================================================
1) ldconfig几个需要注意的地方：
1. 往/lib和/usr/lib里面加东西，是不用修改/etc/ld.so.conf的，但是完了之后要调一下ldconfig，不然这个library会找不到
2. 想往上面两个目录以外加东西的时候，一定要修改/etc/ld.so.conf，然后再调用ldconfig，不然也会找不到
   example:
      比如安装了一个mysql到/usr/local/mysql，mysql有一大堆library在/usr/local/mysql/lib下面，
      这时就需要在/etc/ld.so.conf下面加一行/usr/local/mysql/lib，保存过后ldconfig一下，
      新的library才能在程序运行时被找到。
3. 如果想在这两个目录以外放lib，但是又不想在/etc/ld.so.conf中加东西（或者是没有权限加东西）。
   那也可以，就是export一个全局变量LD_LIBRARY_PATH，然后运行程序的时候就会去这个目录中找library。
   一般来讲这只是一种临时的解决方案，在没有权限或临时需要的时候使用。
4. ldconfig做的这些东西都与运行程序时有关，跟编译时一点关系都没有。编译的时候还是该加-L就得加，不要混淆了。
5. 总之，就是不管做了什么关于library的变动后，最好都ldconfig一下，不然会出现一些意想不到的结果。不会花太多的时间，但是会省很多的事。


2) ldconfig命令参数：
ldconfig通常在系统启动时运行,而当用户安装了一个新的动态链接库时,就需要手工运行这个命令.
ldconfig命令行用法如下:
ldconfig [-v|--verbose] [-n] [-N] [-X] [-f CONF] [-C CACHE] [-r ROOT] [-l] [-p|--print-cache] [-c FORMAT] [--format=FORMAT] [-V] [-?|--help|--usage] path...
ldconfig可用的选项说明如下:
(1) -v或--verbose : 用此选项时,ldconfig将显示正在扫描的目录及搜索到的动态链接库,还有它所创建的连接的名字.
(2) -n : 用此选项时,ldconfig仅扫描命令行指定的目录,不扫描默认目录(/lib,/usr/lib),也不扫描配置文件/etc/ld.so.conf所列的目录.
(3) -N : 此选项指示ldconfig不重建缓存文件(/etc/ld.so.cache).若未用-X选项,ldconfig照常更新文件的连接.
(4) -X : 此选项指示ldconfig不更新文件的连接.若未用-N选项,则缓存文件正常更新.
(5) -f CONF : 此选项指定动态链接库的配置文件为CONF,系统默认为/etc/ld.so.conf.
(6) -C CACHE : 此选项指定生成的缓存文件为CACHE,系统默认的是/etc/ld.so.cache,此文件存放已排好序的可共享的动态链接库的列表.
(7)  -r ROOT : 此选项改变应用程序的根目录为ROOT(是调用chroot函数实现的).选择此项时,系统默认的配置文件 /etc/ld.so.conf,实际对应的为 ROOT/etc/ld.so.conf.如用-r /usr/zzz时,打开配置文件 /etc/ld.so.conf时,实际打开的是/usr/zzz/etc/ld.so.conf文件.用此选项,可以大大增加动态链接库管理的灵活性.
(8) -l : 通常情况下,ldconfig搜索动态链接库时将自动建立动态链接库的连接.选择此项时,将进入专家模式,需要手工设置连接.一般用户不用此项.
(9) -p或--print-cache : 此选项指示ldconfig打印出当前缓存文件所保存的所有共享库的名字.
(10) -c FORMAT 或 --format=FORMAT : 此选项用于指定缓存文件所使用的格式,共有三种: ld(老格式),new(新格式)和compat(兼容格式,此为默认格式).
(11) -V : 此选项打印出ldconfig的版本信息,而后退出.
(12) -? 或 --help 或 --usage : 这三个选项作用相同,都是让ldconfig打印出其帮助信息,而后退出.

实例：

今天在给Awstats安装GeoIP插件的时候，提示找不到一个链接库（libGeoIP.so.1），find发现此文件位于 /usr/local/lib目录，而系统搜索的是/usr/lib目录，本来可以简单的做一个软链接（ln -s）来解决问题，不过我google之后发现了一个更好的方法：

打开/etc/ld.so.conf加入一行：/usr/local/lib
执行/sbin/ldconfig /etc/ld.so.conf
==========================================================================================


==========================================================================================
==				ldd                                                     ==
==========================================================================================
ldd命令：查看使用的动态库文件列表
==========================================================================================


==========================================================================================
==			    QNX memory view                                             ==
==========================================================================================
showmem命令: 查看各个进程的memory（code data heap stack other）
==========================================================================================